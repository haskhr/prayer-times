_J='neptune'
_I='transfer'
_H='mediastore'
_G='elasticache'
_F='apigatewayv2'
_E='apigateway'
_D='athena'
_C='s3'
_B=True
_A='rds'
import logging,os
from localstack import config as localstack_config
from localstack.runtime import hooks
from localstack.runtime.exceptions import LocalstackExit
from localstack.runtime.hooks import on_infra_ready
from localstack.utils import net
from localstack.utils.bootstrap import API_DEPENDENCIES,LocalstackContainer,get_enabled_apis
from localstack.utils.container_utils.container_client import VolumeBind
from localstack.utils.docker_utils import container_ports_can_be_bound
from localstack.utils.net import Port
from localstack_ext import config as config_ext
from localstack_ext.bootstrap import licensing
from localstack_ext.bootstrap.licensing import KeyActivationError,is_enterprise
from localstack_ext.bootstrap.licensingv2 import ENV_LOCALSTACK_AUTH_TOKEN,LICENSE_FILE_NAME,AuthToken,LicensingError,get_credentials_from_environment
LOG=logging.getLogger(__name__)
EXTERNAL_PORT_APIS=_E,_F,_D,'cloudfront','codecommit','ecs','ecr',_G,_H,_A,_I,'kafka',_J
API_DEPENDENCIES.update({'amplify':[_C,'appsync','cognito'],_E:[_F],_D:['emr'],'docdb':[_A],'ecs':['ecr'],_G:['ec2'],'elb':['elbv2'],'emr':[_D,_C],'glacier':[_C],'glue':[_A],'iot':['iotanalytics','iot-data','iotwireless'],'kinesisanalytics':['kinesis','dynamodb'],_J:[_A],_A:['rds-data'],_H:['mediastore-data'],'redshift':['redshift-data'],'timestream':['timestream-write','timestream-query'],_I:[_C]})
get_enabled_apis.cache_clear()
def api_key_configured():return config_ext.is_api_key_configured()
def modify_edge_port_config():
	if os.environ.get('EDGE_PORT')and not localstack_config.EDGE_PORT_HTTP:LOG.warning(('!! Configuring EDGE_PORT={p} without setting EDGE_PORT_HTTP may lead '+'to issues; better leave the defaults, or set EDGE_PORT=443 and EDGE_PORT_HTTP={p}').format(p=localstack_config.EDGE_PORT))
	else:A=localstack_config.EDGE_PORT;localstack_config.EDGE_PORT=443;localstack_config.EDGE_PORT_HTTP=A
@hooks.on_infra_start(should_load=config_ext.ACTIVATE_PRO)
def add_custom_edge_routes():from localstack.services.edge import ROUTER as A;from localstack_ext.services.xray.routes import store_xray_records as B;A.add('/xray_records',B,methods=['POST'])
@hooks.prepare_host(priority=200)
def patch_community_pro_detection():from localstack.utils import bootstrap as A;A.is_api_key_configured=config_ext.is_api_key_configured
@hooks.prepare_host(priority=100,should_load=config_ext.ACTIVATE_PRO)
def activate_pro_key_on_host():
	try:
		with licensing.prepare_environment(raise_exception=_B):LOG.debug('pro activation done')
	except(KeyActivationError,LicensingError)as A:raise LocalstackExit(reason=A.get_user_friendly(),code=55)
@hooks.on_infra_start(should_load=config_ext.ACTIVATE_PRO)
def start_dns_server():
	try:from localstack_ext.services import dns_server as A;A.start_dns_server(asynchronous=_B)
	except Exception as B:LOG.warning('Unable to start DNS: %s',B)
@hooks.prepare_host(should_load=config_ext.ACTIVATE_PRO)
def start_ec2_daemon():
	try:
		if config_ext.EC2_AUTOSTART_DAEMON:from localstack_ext.bootstrap import local_daemon as A;LOG.debug('Starting EC2 daemon...');A.start_in_background()
	except Exception as B:LOG.warning('Unable to start local daemon process: %s'%B)
@hooks.configure_localstack_container(priority=10,should_load=config_ext.ACTIVATE_PRO)
def configure_pro_container(container):
	I='--expose';H='udp';G='tcp';C=container
	try:
		from localstack_ext.constants import DNS_PORT as A;B=[]
		if config_ext.use_custom_dns():
			J=[Port(A,protocol=G),Port(A,protocol=H)]
			if container_ports_can_be_bound(J):
				if not net.is_port_open(A,protocols=G):B+=['-p','{a}:{p}:{p}'.format(a=config_ext.DNS_ADDRESS,p=A)]
				if not net.is_port_open(A,protocols=H):B+=['-p','{a}:{p}:{p}/udp'.format(a=config_ext.DNS_ADDRESS,p=A)]
			else:LOG.info('Unable to bind port 53 - DNS will only be available within Docker, but not on the host');B+=[I,'{p}'.format(p=A)];B+=[I,'{p}/udp'.format(p=A)]
		C.additional_flags.extend(B)
	except Exception as K:LOG.warning('failed to configure DNS: %s',K)
	modify_edge_port_config();D=os.path.expanduser('~/.kube/config')
	if os.path.exists(D):C.volumes.add(VolumeBind(D,'/root/.kube/config'))
	E=get_credentials_from_environment()
	if isinstance(E,AuthToken):C.env_vars[ENV_LOCALSTACK_AUTH_TOKEN]=E.encoded()
	F=os.path.join(localstack_config.dirs.cache,LICENSE_FILE_NAME)
	if os.path.exists(F):L=localstack_config.Directories.for_container().config+'/'+LICENSE_FILE_NAME;C.volumes.add(VolumeBind(F,L,read_only=_B))
@hooks.on_infra_start(should_load=is_enterprise,priority=100)
def configure_enterprise():from localstack import config as A;LOG.debug('Disabling SSL cert download (enterprise image).');A.SKIP_SSL_CERT_DOWNLOAD=_B
@hooks.on_infra_start(should_load=config_ext.ACTIVATE_PRO,priority=10)
def setup_pro_infra():
	_setup_logging();modify_edge_port_config()
	try:
		with licensing.prepare_environment(raise_exception=_B):
			try:from localstack_ext.services import dns_server as B;B.setup_network_configuration()
			except Exception as A:LOG.warning('error setting up dns server: %s',A)
			try:from localstack_ext.aws.protocol import service_router as C;from localstack_ext.services import edge;from localstack_ext.utils.aws import aws_utils as D;C.patch_service_router();edge.patch_start_edge();patch_start_infra();D.patch_aws_utils();set_default_providers_to_pro()
			except Exception as A:
				if LOG.isEnabledFor(level=logging.DEBUG):LOG.exception('error enabling pro code')
				else:LOG.error('error enabling pro code: %s',A)
	except(KeyActivationError,LicensingError)as A:raise LocalstackExit(reason=A.get_user_friendly(),code=55)
def set_default_providers_to_pro():
	D='pro';from localstack.services.plugins import SERVICE_PLUGINS as A
	if not config_ext.PROVIDER_FORCE_EXPLICIT_LOADING:
		for(B,E)in localstack_config.SERVICE_PROVIDER_CONFIG._provider_config.items():
			F=A.api_provider_specs[B];C=[A for A in F if A==f"{E}_pro"]
			if C:localstack_config.SERVICE_PROVIDER_CONFIG.set_provider(B,C[0])
	G=A.apis_with_provider(D);localstack_config.SERVICE_PROVIDER_CONFIG.bulk_set_provider_if_not_exists(G,D)
def patch_start_infra():
	from localstack.services import infra as A
	def B(asynchronous,apis,is_in_docker,*A,**B):
		D=config_ext.ENFORCE_IAM
		try:config_ext.ENFORCE_IAM=False;return C(asynchronous,apis,is_in_docker,*A,**B)
		finally:config_ext.ENFORCE_IAM=D
	C=A.do_start_infra;A.do_start_infra=B
@on_infra_ready(should_load=config_ext.ACTIVATE_PRO)
def initialize_health_info():from localstack_ext.utils.persistence import update_persistence_health_info as A;A()
@hooks.on_infra_start(priority=100)
def deprecation_warnings_pro():C='2.2.0';from localstack.deprecations import DEPRECATIONS as A,EnvVarDeprecation as B;A.append(B('EC2_AUTOSTART_DAEMON',C,'The localstack local daemons will be removed in the future, please let us know if you are actively using them.'));A.append(B('AUTOSTART_UTIL_CONTAINERS',C,'This configuration flag is no longer required with the bigdata mono container mode, which is now the default. It will be removed in a future version.'))
def _setup_logging():A=logging.DEBUG if localstack_config.DEBUG else logging.INFO;logging.getLogger('localstack_ext').setLevel(A);logging.getLogger('asyncio').setLevel(logging.INFO);logging.getLogger('botocore').setLevel(logging.INFO);logging.getLogger('dulwich').setLevel(logging.ERROR);logging.getLogger('hpack').setLevel(logging.INFO);logging.getLogger('jnius.reflect').setLevel(logging.INFO);logging.getLogger('kazoo').setLevel(logging.ERROR);logging.getLogger('kubernetes').setLevel(logging.INFO);logging.getLogger('parquet').setLevel(logging.INFO);logging.getLogger('pyftpdlib').setLevel(logging.INFO);logging.getLogger('pyhive').setLevel(logging.INFO);logging.getLogger('pyqldb').setLevel(logging.INFO);logging.getLogger('redshift_connector').setLevel(logging.INFO);logging.getLogger('websockets').setLevel(logging.INFO);logging.getLogger('Parser').setLevel(logging.CRITICAL);logging.getLogger('postgresql_proxy').setLevel(logging.WARNING);logging.getLogger('intercept').setLevel(logging.WARNING);logging.getLogger('root').setLevel(logging.WARNING);logging.getLogger('').setLevel(logging.WARNING)