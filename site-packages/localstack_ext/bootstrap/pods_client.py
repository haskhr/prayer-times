_I='Timeout exceed for the pod load operation. To avoid this issue, try to increase thevalue of the POD_LOAD_CLI_TIMEOUT configuration variable.'
_H='merge_strategy'
_G='pod_version'
_F='services'
_E='pod_name'
_D='remote'
_C=True
_B=False
_A=None
import io,json,logging,os,zipfile
from abc import ABC,abstractmethod
from collections import defaultdict
from dataclasses import dataclass,field
from enum import Enum
from functools import singledispatch
from pathlib import Path
from typing import Callable,Dict,List,Optional,Set,Tuple,TypedDict
from urllib.parse import urlparse
import requests,yaml
from click import ClickException
from localstack import config
from localstack.cli import console
from localstack.constants import APPLICATION_JSON,HEADER_CONTENT_TYPE
from localstack.utils.files import load_file,new_tmp_file,rm_rf,save_file
from localstack.utils.http import download,safe_requests
from localstack.utils.strings import to_str
from requests.structures import CaseInsensitiveDict
from localstack_ext.bootstrap import licensing
from localstack_ext.bootstrap.pods.api_types import DEFAULT_MERGE_STRATEGY,MergeStrategy
from localstack_ext.bootstrap.pods.fs import CloudPodsFileSystem
from localstack_ext.bootstrap.pods.models import Version
from localstack_ext.bootstrap.pods.remote import CloudPodsRemote,CloudPodsRemoteManager,RemoteConfig,create_platform_url
from localstack_ext.bootstrap.pods.remotes.api import CloudPodsRemotesClient
from localstack_ext.bootstrap.pods.service_state.service_state import ServiceState
from localstack_ext.bootstrap.pods.utils.adapters import ServiceStateMarshaller
from localstack_ext.bootstrap.pods.utils.common import PodsConfigContext
from localstack_ext.config import POD_LOAD_CLI_TIMEOUT
from localstack_ext.constants import API_PATH_PODS,API_STATES_DIR,ASSETS_DIRECTORY,CLOUDPODS_METADATA_FILE
LOG=logging.getLogger(__name__)
HEADER_LS_API_KEY='ls-api-key'
HEADER_LS_VERSION='ls-version'
HEADER_AUTHORIZATION='Authorization'
class PodLocation(Enum):REMOTE=_D;LOCAL='local'
@dataclass
class PodMetadata:services:List[str]=field(default_factory=list);size:int=0
def get_state_zip_from_instance(services=_A):
	B=services;C=f"{get_pods_endpoint()}/state";D=','.join(B)if B else'';A=requests.get(C,params={_F:D});E=PodMetadata(services=A.headers.get('x-localstack-pod-services','').split(','),size=int(A.headers.get('x-localstack-pod-size',0)))
	if A.status_code>=400:raise Exception(f"Unable to get local pod state via management API {C} (code {A.status_code}): {A.content}")
	return A.content,E
class CloudPodsManager:
	pod_name:str;remote_config:Optional[RemoteConfig]
	def __init__(A,pod_name,remote_config=_A):B=pod_name;A.pod_name=B;A.remote_config=remote_config;C=PodsConfigContext(pod_name=B);A.pods_fs_ops=CloudPodsFileSystem(C)
	def init(A):A.pods_fs_ops.init(pod_name=A.pod_name)
	def _add_state_to_cloud_pods_store(A,extract_assets=_B,services=_A):
		if not A.pods_fs_ops.config_context.is_initialized():LOG.debug('No Cloud Pod instance detected in the local context - unable to add state');return
		E,L=get_state_zip_from_instance(services=services);C=ServiceStateMarshaller.unmarshall(E,raw_bytes=_C)
		for(B,F)in C.state.items():
			for(G,H)in F.backends.items():A.pods_fs_ops.create_state_file_from_fs(file_name=G,service=B.service,region=B.region,root=API_STATES_DIR,account_id=B.account_id,object=H)
		if extract_assets:
			for(I,J)in C.assets.items():
				for(D,K)in J.items():A.pods_fs_ops.create_state_file_from_fs(rel_path=D,file_name=os.path.basename(D),service=I,region='NA',root=ASSETS_DIRECTORY,account_id='NA',object=K)
	def delete(A,remote):
		C=A.pods_fs_ops.config_context.cloud_pods_root_dir;B=os.path.join(C,A.pod_name)
		if os.path.isdir(B):rm_rf(B);return _C
		if remote:return A.remote.delete_pod(A.pod_name)
		return _B
	def push(A,comment=_A,services=_A):
		A.pods_fs_ops.set_pod_context(A.pod_name);B=A.pods_fs_ops.get_max_version();C=A.remote.is_registered(A.pod_name)
		if C:
			E=A.remote.get_max_version(pod_name=A.pod_name);F=not B or B.version_number<E
			if F:A.pull(inject=_B)
		A._add_state_to_cloud_pods_store(extract_assets=_C,services=services);D=A.pods_fs_ops.push(comment=comment)
		if C:A.remote.push_pod(A.pod_name,version=D.version_number)
		LOG.debug("Created new version %s for pod '%s'",D.version_number,A.pod_name)
	def push_overwrite(A,version,comment=_A,services=_A):
		B=version;A.pods_fs_ops.set_pod_context(pod_name=A.pod_name);C=A.pods_fs_ops.get_max_version_no()
		if C and B>C:LOG.warning(f"Version {B} does not exist");return _B
		A._add_state_to_cloud_pods_store(services=services);A.pods_fs_ops.push_overwrite(version=B,comment=comment)
		if A.remote.is_registered(A.pod_name):A.remote.push_pod(A.pod_name,version=B,overwrite=_C)
		return _C
	def pull(A,inject=_C,merge_strategy=_A):
		D=merge_strategy
		if D is _A:D=DEFAULT_MERGE_STRATEGY
		B=0;C=A.pod_name
		if C in A.pods_fs_ops.list_locally_available_pods():A.pods_fs_ops.set_pod_context(C);B=A.pods_fs_ops.get_max_version_no()
		else:A.pods_fs_ops.init(pod_name=C)
		E=A.remote.get_max_version(C)
		if not E:return _B
		B=B or 0
		if E>B:F=list(range(B+1,E+1));A.remote.pull_versions(pod_name=C,required_versions=F)
		else:LOG.info('No new version available remotely')
		if inject:LOG.info('Injecting the cloud pod state into the running instance');return A.inject(version=-1,merge_strategy=D)
		return _C
	def commit(A,message=_A,services=_A):A.pods_fs_ops.set_pod_context(A.pod_name);A._add_state_to_cloud_pods_store(services=services);B=A.pods_fs_ops.commit(message=message);LOG.debug('Completed revision: %s',B.hash_ref)
	@staticmethod
	def deploy_pod_into_instance(pod_name,pod_version,pod_path,merge_strategy):
		A=pod_path
		if not A:raise Exception(f"Unable to restore pod state via local pods management API: Pod Path {A} not valid")
		try:
			D=load_file(A,mode='rb');C=get_pods_endpoint();E={_E:pod_name,_G:pod_version,_H:merge_strategy}
			try:B=requests.post(C,data=D,params=E,timeout=POD_LOAD_CLI_TIMEOUT)
			except requests.exceptions.Timeout as F:raise Exception(_I)from F
			if B.status_code>=400:raise Exception(f"Unable to restore pod state via local pods management API {C} (code {B.status_code}): {B.content}")
		except requests.exceptions.ReadTimeout:LOG.debug('Returning from cloud pod inject operation - continues to run in the background...')
	def inject(A,version=-1,merge_strategy=_A):
		D=merge_strategy;C=version
		if D is _A:D=MergeStrategy.MERGE
		if not A.pods_fs_ops.config_context.pod_exists_locally(A.pod_name):raise Exception(f"Unable to find a local version of pod {A.pod_name}")
		A.pods_fs_ops.set_pod_context(A.pod_name)
		if C==-1:C=A.pods_fs_ops.get_max_version_no()or 0
		B=A.pods_fs_ops.config_context.get_version_state_archive();E=_B
		try:
			if not B and C<=Version.DEFAULT_INITIAL_VERSION_NUMBER:B=new_tmp_file();F=A.pods_fs_ops.get_version_by_number(C);G=A.pods_fs_ops.get_state_archive_from_state_files(version=F);save_file(B,G);E=_C
			if not B and A.remote.is_registered(A.pod_name):raise Exception(f"Unable to find a local version of pod {A.pod_name}")
			if not B:raise Exception(f"Unable to find state archive for cloud pod '{A.pod_name}' version {C}")
			A.deploy_pod_into_instance(pod_name=A.pods_fs_ops.config_context.pod_name,pod_version=C,pod_path=B,merge_strategy=D);return _C
		except Exception as H:LOG.debug('An exception occurred while trying to load Cloud Pod %s: "%s"',A.pod_name,H);return _B
		finally:
			if E:rm_rf(B)
	def get_version_summaries(A):A.pods_fs_ops.set_pod_context(A.pod_name);B=A.pods_fs_ops.get_version_summaries();return B
	def list_version_commits(A,version):A.pods_fs_ops.set_pod_context(A.pod_name);B=A.pods_fs_ops.list_version_commits(version_no=version);C=[A.get_summary()for A in B];return C
	def register_remote(A,ci_pod=_A):return A.remote.register_remote(A.pod_name,ci_pod=ci_pod)
	def list_pods(B,local=_B):
		C={A:{PodLocation.LOCAL.value}for A in B.pods_fs_ops.list_locally_available_pods()}
		if local:return C
		D=C or defaultdict(set);E=B.remote.list_pods()
		for A in E or[]:F=A.get(_E)if isinstance(A,dict)else A;D.setdefault(F,set()).add(PodLocation.REMOTE.value)
		return{A:list(B)for(A,B)in D.items()}
	@property
	def remote(self):
		A=self;E=CloudPodsRemoteManager(A.pods_fs_ops.config_context,A.remote_config);B=''
		if A.remote_config and A.remote_config.remote_url:B=A.remote_config.remote_url
		C=urlparse(B).scheme or'platform';D=E.get_plugin_for_protocol(protocol=C)
		if not D:raise Exception(f"Unable to find remote implementation for protocol '{C}'")
		return D
class PodConfigManagerMeta(type):
	def __getattr__(C,attr):
		def A(*D,**E):
			A=_A
			for F in C.CHAIN:
				try:
					B=getattr(F,attr)(*D,**E)
					if B:
						if not A:A=B
						elif isinstance(B,list)and isinstance(A,list):A.extend(B)
				except Exception:
					if LOG.isEnabledFor(logging.DEBUG):LOG.exception('error during PodConfigManager call chain')
			if A is not _A:return A
			raise Exception(f'Unable to run operation "{attr}" for local or remote configuration')
		return A
class PodConfigManager(metaclass=PodConfigManagerMeta):
	CHAIN=[]
	@classmethod
	def pod_config(D,pod_name):
		A=pod_name;C=PodConfigManager.list_pods();B=[B for B in C if B[_E]==A]
		if not B:raise Exception(f'Unable to find config for pod named "{A}"')
		return B[0]
def get_pods_manager(pods_name,remote_config=_A):return CloudPodsManager(pod_name=pods_name,remote_config=remote_config)
class CloudPodRemoteAttributes(TypedDict,total=_B):is_public:bool;comment:Optional[str];services:Optional[List[str]]
class CloudPodsService(ABC):
	@abstractmethod
	def save(self,pod_name,attributes=_A,remote=_A,local=_B):0
	@abstractmethod
	def delete(self,pod_name,remote=_A):0
	@abstractmethod
	def load(self,pod_name,remote=_A):0
	@abstractmethod
	def list(self,remote=_A):0
	@abstractmethod
	def get_versions(self,pod_name,remote=_A):0
	def get_metamodel(B,pod_name,version,remote=_A):
		A=requests.get(url=f"{get_pods_endpoint()}/state/metamodel",headers=_get_headers())
		if not A.ok:_raise_exception_with_formatted_message(f"Unable to get metamodel for pod {pod_name}",A)
		return json.loads(A.content)
	def set_remote_attributes(G,pod_name,attributes,remote=_A):
		D='is_public';C=remote;B=pod_name
		if C:LOG.debug(f"Trying to set attributes for remote '{C}'. Currently we support attributes only for thedefault remote");return
		E=create_platform_url(B);F=licensing.get_auth_headers();A=safe_requests.patch(E,headers=F,json={D:attributes[D]})
		if not A.ok:raise Exception(f"Error setting remote attributes for Cloud Pod {B} (code {A.status_code}): {A.text}")
def _get_headers():
	B={HEADER_CONTENT_TYPE:APPLICATION_JSON};C=CaseInsensitiveDict(licensing.get_auth_headers())
	for A in(HEADER_AUTHORIZATION,HEADER_LS_API_KEY,HEADER_LS_VERSION):
		if C.get(A):B[A]=C[A]
	return B
def _raise_exception_with_formatted_message(message,response):A=response;raise Exception(f"{message} (code {A.status_code}): {A.text}")
class CloudPodsClient(CloudPodsService):
	def save(E,pod_name,attributes=_A,remote=_A,local=_B):
		B=remote;A=pod_name;C=f"{get_pods_endpoint()}/{A}"
		if local:C+='?local=true'
		D=requests.post(url=C,headers=_get_headers(),data=json.dumps({_D:B}if B else{}))
		if not D.ok:_raise_exception_with_formatted_message(f"Unable to save pod {A}",D)
	def delete(D,pod_name,remote=_A):
		B=remote;A=pod_name;C=requests.delete(url=f"{get_pods_endpoint()}/{A}",headers=_get_headers(),data=json.dumps({_D:B}if B else{}))
		if not C.ok:_raise_exception_with_formatted_message(f"Unable to delete pod {A}",C)
	def load(D,pod_name,remote=_A):
		B=remote;A=pod_name;C=requests.put(url=f"{get_pods_endpoint()}/{A}",headers=_get_headers(),data=json.dumps({_D:B}if B else{}))
		if not C.ok:_raise_exception_with_formatted_message(f"Unable to load pod {A}",C)
	def list(C,remote=_A):
		B=remote;A=requests.get(url=f"{get_pods_endpoint()}",headers=_get_headers(),data=json.dumps({_D:B}if B else{}))
		if not A.ok:_raise_exception_with_formatted_message('Unable to list Cloud Pods',A)
		return json.loads(A.content)
	def get_versions(D,pod_name,remote=_A):
		C=remote;B=pod_name;A=requests.get(url=f"{get_pods_endpoint()}/{B}/versions",data=json.dumps({_D:C}if C else{}),headers=_get_headers())
		if A.status_code==404:raise Exception(f"Cloud Pod {B} not found")
		if not A.ok:_raise_exception_with_formatted_message(f"Unable to get versions for pod {B}",A)
		return json.loads(A.content).get('versions',[])
def _get_remote_configuration(name):
	B=CloudPodsRemotesClient()
	try:A=B.get_remote(name=name)
	except Exception as C:raise ClickException(f"Error getting configuration for the remote {name}")from C
	LOG.debug('Remote configuration: %s',A);return RemoteConfig(remote_url=A['remote_url'])
class CloudPodsClientLegacy(CloudPodsService):
	def save(F,pod_name,attributes=_A,remote=_A,local=_B):
		D=remote;C=pod_name;B=attributes;E=_get_remote_configuration(name=D)if D else _A;A=get_pods_manager(pods_name=C,remote_config=E)
		if not A.pods_fs_ops.config_context.is_initialized():A.init()
		A.pods_fs_ops.set_pod_context(pod_name=C);B=B or{};A.push(comment=B.get('comment'),services=B.get(_F))
		if not local:A.register_remote()
	def delete(D,pod_name,remote=_A):A=remote;B=_get_remote_configuration(name=A)if A else _A;C=get_pods_manager(pods_name=pod_name,remote_config=B);C.delete(remote=_C)
	def load(D,pod_name,remote=_A,local=_B):A=remote;B=_get_remote_configuration(name=A)if A else _A;C=get_pods_manager(pods_name=pod_name,remote_config=B);C.pull(inject=_C)
	def list(D,remote=_A):A=remote;B=_get_remote_configuration(name=A)if A else _A;C=get_pods_manager(pods_name='',remote_config=B);return C.list_pods()
	def get_versions(E,pod_name,remote=_A):
		B=remote;A=pod_name;D=_get_remote_configuration(name=B)if B else _A;C=get_pods_manager(pods_name=A,remote_config=D)
		if not C.pods_fs_ops.config_context.is_initialized():raise Exception(f'Cloud Pod "{A}" not found')
		return C.get_version_summaries()[::-1]
	def list_public_pods(E):
		B=create_platform_url('public');C=licensing.get_auth_headers();A=safe_requests.get(B,headers=C)
		if not A.ok:raise Exception(to_str(A.content))
		D=json.loads(A.content);return[A[_E]for A in D]
def get_pods_endpoint():A=config.get_edge_url();return f"{A}{API_PATH_PODS}"
class CloudPodsLocalService:
	def export_pod(I,target):
		C=target;F,G=get_state_zip_from_instance();D=urlparse(C);A=os.path.abspath(os.path.join(D.netloc,D.path));E=Path(A).parent.absolute()
		if not os.path.exists(E):raise Exception(f"{E} is not a valid path")
		save_file(file=A,content=F);B=get_environment_metadata();B['name']=os.path.basename(C);B.update(G.__dict__)
		with zipfile.ZipFile(file=A,mode='a')as H:H.writestr(CLOUDPODS_METADATA_FILE,yaml.dump(B))
		return _C
	def import_pod(H,source):
		C='pro';A=source;D=get_protocol_access(A);B=D(A);E=zipfile.ZipFile(io.BytesIO(B),'r');F=read_metadata_from_pod(E)or{};G=get_environment_metadata().get(C)
		if F.get(C,_B)and not G:console.print('Warning: You are trying to load a Cloud Pod generated with a Pro license.The loaded state might be incomplete.')
		return inject_pod_endpoint(content=B)
@singledispatch
def read_metadata_from_pod(zip_file):
	try:A=yaml.safe_load(zip_file.read(CLOUDPODS_METADATA_FILE));return A
	except KeyError:LOG.debug('No %s file in the archive',CLOUDPODS_METADATA_FILE)
@read_metadata_from_pod.register(bytes)
def _(zip_file):A=zip_file;A=zipfile.ZipFile(io.BytesIO(A),'r');return read_metadata_from_pod(A)
@read_metadata_from_pod.register(str)
def _(zip_file):
	with zipfile.ZipFile(zip_file)as A:return read_metadata_from_pod(A)
def inject_pod_endpoint(content,pod_name='community_pod',pod_version=1,merge_strategy=DEFAULT_MERGE_STRATEGY):
	A=get_pods_endpoint();B={_E:pod_name,_G:str(pod_version),_H:merge_strategy}
	try:C=requests.post(A,data=content,params=B,timeout=POD_LOAD_CLI_TIMEOUT)
	except requests.exceptions.Timeout as D:raise Exception(_I)from D
	return C.ok
def get_environment_metadata():
	C=get_pods_endpoint();A=f"{C}/environment";B=requests.get(A)
	if not B.ok:raise Exception(f"Unable to retrieve environment metadata from {A}")
	return json.loads(B.content)
def get_git_base_url(user,repo):return f"https://raw.githubusercontent.com/{user}/{repo}/main"
def get_protocol_access(url):
	A=urlparse(url).scheme
	if A=='file':return get_zip_content_from_file
	elif A in['http','https']:return get_zip_content_from_http
	elif A=='git':return get_zip_content_from_git
	raise Exception(f"Protocol {A} not valid")
def get_zip_content_from_file(url):
	B=url;B=urlparse(B);A=os.path.abspath(os.path.join(B.netloc,B.path))
	if not os.path.isfile(A):raise Exception(f"Path {A} is not a file")
	if not os.path.exists(A):raise Exception(f"Path {A} does not exist")
	return load_file(A,mode='rb')
def get_zip_content_from_http(url):
	A=requests.get(url)
	if not A.ok:raise Exception('Unable to fetch Cloud Pod from URL %s: %s %s',url,A.status_code,A.content)
	return A.content
def get_zip_content_from_git(url):
	E=url[len('git://'):];A=E.split('/');F,G,H=A[0],A[1],A[2];I=f"{get_git_base_url(F,G)}";C=f"{I}/{H}";B=new_tmp_file()
	try:download(C,B);return load_file(B,mode='rb')
	except Exception as D:raise Exception(f"Failed to download Cloud Pod from URL {C}: {D}")from D
	finally:rm_rf(B)
def reset_state(services=_A):
	B=services
	def C(_url):
		A=requests.post(_url)
		if not A.ok:LOG.debug('Reset call to %s failed: status code %s',_url,A.status_code);raise Exception('Failed to reset LocalStack')
	if not B:A=f"{config.get_edge_url()}/_localstack/state/reset";C(A);return
	for D in B:A=f"{config.get_edge_url()}/_localstack/state/{D}/reset";C(A)