_F='pod_name'
_E='max_version'
_D='platform'
_C='presigned_urls'
_B=True
_A=False
import json,logging
from dataclasses import dataclass
from typing import Dict,List,Optional,Tuple
from localstack import config,constants
from localstack.utils.files import new_tmp_file
from localstack.utils.http import download,safe_requests
from localstack.utils.strings import to_str
from plugin import Plugin,PluginManager
from requests import Response
from localstack_ext.bootstrap import licensing
from localstack_ext.bootstrap.pods.fs import CloudPodPreSignedUrls,CloudPodsFileSystem
from localstack_ext.bootstrap.pods.remotes.api import CloudPodsRemotesClient
LOG=logging.getLogger(__name__)
@dataclass
class RemoteConfig:remote_url:str
PODS_REMOTE_NAMESPACE='localstack.pods.remote'
class CloudPodsRemote(Plugin):
	namespace=PODS_REMOTE_NAMESPACE;name:str;protocols:set[str];remote_config:RemoteConfig;pods_fs_ops:CloudPodsFileSystem
	def load(A,*B,**C):A.remote_config=B[1];A.pods_fs_ops=CloudPodsFileSystem(B[0])
	def list_pods(A):raise NotImplementedError
	def get_max_version(A,pod_name):raise NotImplementedError
	def pull_versions(A,pod_name,required_versions):raise NotImplementedError
	def is_registered(A,pod_name):raise NotImplementedError
	def push_pod(A,pod_name,version,overwrite=_A):raise NotImplementedError
	def register_remote(A,pod_name,ci_pod=None):raise NotImplementedError
	def rename_pod(A,current_name,new_name):raise NotImplementedError
	def delete_pod(A,pod_name):raise NotImplementedError
def create_platform_url(path=None):
	A=path;B=f"{constants.API_ENDPOINT}/cloudpods"
	if not A:return B
	A=A if A.startswith('/')else f"/{A}";return f"{B}{A}"
class CloudPodsRemotePlatform(CloudPodsRemote):
	name=_D;protocols={_D}
	def get_max_version(A,pod_name):
		C=create_platform_url(pod_name);B=safe_requests.get(url=C,headers=A._get_auth_headers());D='Failed to get version information from platform.. aborting'
		if not A._check_response(B,message=D,raise_error=_B):return
		E=json.loads(B.content);F=int(E[_E]);return F
	def pull_versions(A,pod_name,required_versions):
		C=','.join(str(A)for A in required_versions);D=create_platform_url(f"{pod_name}/data?versions={C}");B=safe_requests.get(url=D,headers=A._get_auth_headers());E='Failed to pull requested versions from platform (code <status_code>)'
		if not A._check_response(B,message=E,raise_error=_B):return
		F=json.loads(B.content);G,H=A._prepare_archives_from_pre_signed_urls(F.get(_C));A.pods_fs_ops.merge_from_remote(versions_archive=G)
	def push_pod(A,pod_name,version,overwrite=_A):
		B=create_platform_url(f"{pod_name}/data?version={version}")
		if overwrite:B+='&overwrite=true'
		C=safe_requests.post(url=B,headers=A._get_auth_headers());D='Failed to get pre-signed URLs to upload new version: <content> (status <status_code>)'
		if not A._check_response(C,message=D,raise_error=_B):return
		E=json.loads(C.content);F=E.get(_C);A.pods_fs_ops.upload_pod_to_pre_signed_urls(pre_signed_urls=F)
	def list_pods(A):C=create_platform_url();B=safe_requests.get(C,headers=A._get_auth_headers());A._check_response(B,message='Error fetching list of pods from API (status <status_code>)',raise_error=_B);D=json.loads(B.content);return D
	def delete_pod(A,pod_name):B=create_platform_url(pod_name);C=safe_requests.delete(url=B,headers=A._get_auth_headers());return C.ok
	def is_registered(C,pod_name):
		A=pod_name
		try:D=create_platform_url();B=safe_requests.get(D,headers=C._get_auth_headers())
		except Exception as E:LOG.debug('An error occurred while checking remote management for pod "%s": "%s"',A,E);return _A
		if not B.ok:return _A
		F=json.loads(B.content);return A in[A[_F]for A in F]
	def register_remote(A,pod_name,ci_pod=None):
		B=pod_name;E=A.pods_fs_ops.get_max_version_no();F=create_platform_url(B);C={_F:B,_E:E,'ci_pod':ci_pod};C=json.dumps(C);D=safe_requests.put(F,C,headers=A._get_auth_headers());G=f"Failed to register pod {B}: <content>"
		if not A._check_response(D,message=G):return _A
		H=json.loads(D.content);I=H.get(_C);A.pods_fs_ops.upload_pod_to_pre_signed_urls(pre_signed_urls=I);return _B
	def rename_pod(B,current_name,new_name):D=new_name;C=current_name;E=create_platform_url(f"{C}/rename");A={'new_pod_name':D};A=json.dumps(A);F=safe_requests.put(E,A,headers=B._get_auth_headers());G=f"Failed to rename {C} to {D}: <content>";return B._check_response(F,message=G)
	def _get_auth_headers(C):
		if not config.is_in_docker:return licensing.get_auth_headers()
		A=CloudPodsRemotesClient();B=A.get_token()or{};return B
	@classmethod
	def _check_response(C,response,message,raise_error=_A):
		B=response;A=message
		if B.ok:return _B
		if B.status_code in[401,403]:raise Exception('Access denied - please log in first.')
		A=A.replace('<content>',to_str(B.content));A=A.replace('<status_code>',str(B.status_code))
		if raise_error:raise Exception(A)
		LOG.warning(A);return _A
	@staticmethod
	def _prepare_archives_from_pre_signed_urls(pre_signed_urls):A=pre_signed_urls;B=new_tmp_file();D=A.get('versions_archive_url');download(url=D,path=B);C=new_tmp_file();E=A.get('state_archive_url');download(url=E,path=C);return B,C
class CloudPodsRemoteManager(PluginManager[CloudPodsRemote]):
	protocols_to_plugin:dict[str,Plugin]
	def __init__(A,*D,**E):
		super().__init__(PODS_REMOTE_NAMESPACE,load_args=D,load_kwargs=E);A.protocols_to_plugin={};F=A.load_all()
		for C in F:
			G=C.protocols
			for B in G:
				if B in A.protocols_to_plugin:LOG.info('A plugin is already registered for protocol %s => overriding.',B)
				A.protocols_to_plugin[B]=C;LOG.debug('Mapping %s protocol to %s',B,C)
	def get_plugin_for_protocol(A,protocol):return A.protocols_to_plugin.get(protocol)