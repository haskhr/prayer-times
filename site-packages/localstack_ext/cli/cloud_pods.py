_I='curses'
_H='url-or-name'
_G="Login to save to the Cloud Pod's platform"
_F='url'
_E=True
_D='remote'
_C=False
_B='name'
_A=None
from typing import Dict,List,Optional,Set
from urllib.parse import urlparse
import click,requests
from click import ClickException
from localstack import config
from localstack.cli import console
from localstack.utils.analytics.cli import publish_invocation
from localstack_ext import config as ext_config
from localstack_ext.bootstrap import licensing
from localstack_ext.bootstrap.pods.remotes.api import CloudPodsRemotesClient
from localstack_ext.bootstrap.pods.utils.common import is_comma_delimited_list
from localstack_ext.bootstrap.pods_client import CloudPodRemoteAttributes,CloudPodsClient,CloudPodsClientLegacy,CloudPodsLocalService,CloudPodsService
from localstack_ext.cli.click_utils import print_table
from localstack_ext.cli.tree_view import TreeRenderer
def _assert_host_reachable():
	try:requests.get(config.get_edge_url())
	except requests.ConnectionError:raise ClickException('Destination host unreachable.')
def _get_pod_client():
	if ext_config.ACTIVATE_NEW_POD_CLIENT:return CloudPodsClient()
	return CloudPodsClientLegacy()
@click.group(name='pod',help='Manage the state of your instance via Cloud Pods.',context_settings=dict(max_content_width=120))
def pod():0
@pod.group(name=_D,help='Manage cloud pod remotes')
def remote():0
@remote.command(name='add',short_help='Add a remote')
@click.argument(_B,required=_E)
@click.argument(_F,required=_E)
def cmd_add_remote(name,url):
	A=name;_assert_host_reachable();C=CloudPodsRemotesClient();D=urlparse(url).scheme
	try:C.create_remote(name=A,protocols=[D],remote_url=url)
	except Exception as B:raise ClickException(f"Unable to determine URL for remote '{A}': {B}")from B
	console.print(f"Successfully added remote {A}")
@pod.command(name='remotes',short_help='Lists the available remotes')
def cmd_remotes():
	_assert_host_reachable();B=CloudPodsRemotesClient();A=B.get_remotes()
	if not A:console.print('[yellow]No remotes[/yellow]');return
	print_table(column_headers=['Remote Name','URL'],columns=[[A[_B]for A in A],[A[_F]for A in A]])
@pod.command(name='delete',short_help='Delete a Cloud Pod')
@click.argument(_B)
@publish_invocation
def cmd_pod_delete(name):
	A=name;B=_get_pod_client();C=B.delete(pod_name=A)
	if C:console.print(f"Successfully deleted {A}")
	else:raise ClickException(f"Could not delete Cloud Pod {A}")
@pod.command(name='save',short_help='Create a new Cloud Pod')
@click.argument(_H)
@click.argument(_D,required=_C)
@click.option('-m','--message',help="Add a comment describing this Cloud Pod's version")
@click.option('-s','--services',help='Comma-delimited list of services to push in the Cloud Pod (all by default)')
@click.option('--visibility',type=click.Choice(['public','private']),help='Set the visibility of the Cloud Pod [`public` or `private`]. Does not create a new version')
@publish_invocation
def cmd_pod_save(url_or_name=_A,url=_A,remote=_A,services=_A,message=_A,visibility=_A):
	F=visibility;E=remote;B=services;A=url_or_name;G=_get_pod_client();_assert_host_reachable();H=urlparse(A).scheme=='file'
	if url or H:
		C=url or A;I=CloudPodsLocalService()
		if I.export_pod(target=C):console.print(f"Cloud Pod {C} successfully exported");return
		else:raise ClickException(f"Failed to create Cloud Pod {C}")
	if not licensing.is_logged_in():raise ClickException(_G)
	if B and not is_comma_delimited_list(B):raise ClickException('Input the services as a comma-delimited list')
	if F:
		try:G.set_remote_attributes(pod_name=A,attributes=CloudPodRemoteAttributes(is_public=_E),remote=E)
		except Exception as D:raise ClickException(str(D))
		console.print(f"Cloud Pod {A} made {F}")
	J=[A.strip()for A in B.split(',')]if B else _A
	try:G.save(pod_name=A,attributes={'comment':message,'services':J},remote=E)
	except Exception as D:raise ClickException(f"Failed to create Cloud Pod {A}")from D
	console.print(f"Cloud Pod {A} successfully created")
@pod.command(name='load')
@click.argument(_H)
@click.argument(_D,required=_C)
@publish_invocation
def cmd_pod_load(url_or_name=_A,url=_A,remote=_A):
	B=url;A=url_or_name;D=_get_pod_client();_assert_host_reachable();C=urlparse(B or A).scheme in['file','http','https','git']
	if not C and not licensing.is_logged_in():raise ClickException("It seems you are trying to access the Cloud Pod's platform.\nPlease login first.")
	if B or C:
		E=CloudPodsLocalService();F=E.import_pod(source=B or A)
		if F:console.print(f"Cloud Pod {A or B} successfully loaded");return
		else:raise ClickException(f"Failed to load Cloud Pod {A or B}")
	if not licensing.is_logged_in():raise ClickException(_G)
	try:D.load(pod_name=A,remote=remote)
	except Exception:raise ClickException(f"Failed to load Cloud Pod {A or B}")
	print(f"Cloud Pod {A} successfully loaded")
@pod.command(name='list',short_help='List all available Cloud Pods')
@click.argument(_D,required=_C)
@click.option('--public','-p',help='List all the available public Cloud Pods',is_flag=_E,default=_C)
@publish_invocation
def cmd_pod_list_pods(remote=_A,public=_C):
	B=_get_pod_client()
	if public:C=CloudPodsClientLegacy().list_public_pods();print_table(column_headers=['Cloud Pod'],columns=[C]);return
	A=B.list(remote=remote)
	if not A:console.print('[yellow]No pods available[/yellow]')
	print_table(column_headers=['local/remote','Name'],columns=[['local+remote'if len(A)>1 else list(A)[0]for A in list(A.values())],list(A.keys())])
@pod.command(name='versions')
@click.argument(_B)
@publish_invocation
def cmd_pod_versions(name):
	B=_get_pod_client()
	try:C=B.get_versions(pod_name=name)
	except Exception as A:raise ClickException(str(A))from A
	D='\n'.join(C);console.print(D)
@pod.command(name='inspect')
@click.argument(_B)
@click.option('-f','--format','format_',type=click.Choice([_I,'rich','json']),default=_I,help='The formatting style for the inspect command output.')
@publish_invocation
def cmd_pod_inspect(name,format_):
	B=_get_pod_client()
	try:A=B.get_metamodel(pod_name=name,version=-1)
	except Exception:raise ClickException('Error occurred while fetching the metamodel')
	C=['cloudwatch']
	for(D,E)in A.items():A[D]={A:B for(A,B)in E.items()if A not in C}
	TreeRenderer.get(format_).render_tree(A)
def get_pods_community_commands():A=click.Group(name='pod',help='Manage the state of your instance via Cloud Pods',context_settings=dict(max_content_width=120));[A.add_command(B)for B in community_pods_commands];cmd_pod_save.params=list(filter(lambda x:isinstance(x,click.Argument),cmd_pod_save.params));cmd_pod_save.params=[cmd_pod_save.params[0]];cmd_pod_save.params[0].name=_F;cmd_pod_save.short_help='Create a new Cloud Pod and saves it to disk';cmd_pod_save.help='\n    Save the current state of the LocalStack container in a Cloud Pod.\n    To export on a local path run the following command:\n\n    localstack pod save file://<path_on_disk>/<pod_name>\n\n    The output will be a <pod_name> zip file in the specified directory. This Cloud Pod instance can be restored at any\n    point in time with the load command.\n    ';cmd_pod_load.params=list(filter(lambda x:isinstance(x,click.Argument),cmd_pod_load.params));cmd_pod_load.params=[cmd_pod_load.params[0]];cmd_pod_load.params[0].name=_F;cmd_pod_load.short_help='Load the state of a Cloud Pod into the application runtime from a given URL';cmd_pod_load.help="\n    Load a Cloud Pod into the running LocalStack container. Users can import Pods from different sources, i.e., local\n    storage or any provided HTTP URL.\n\n    Use the URL argument to specify the URL where the Cloud Pod's content is stored.\n\n    \x08\n    We support the following protocols:\n    localstack pod load file://<path_to_disk>\n    localstack pod load https://<some_url>\n    localstack pod load git://<user>/<repo>/<local_repo_path>\n\n    The latter option is merely a shortcut for:\n    \x08\n    localstack pod load https://raw.githubusercontent.com/<user>/<repo>/<branch>/<path>\n\n    Importing via a provided a given URL is available to all users.\n    ";return A
community_pods_commands=[cmd_pod_save,cmd_pod_load]